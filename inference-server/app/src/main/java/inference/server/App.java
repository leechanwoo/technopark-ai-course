/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package inference.server;

import io.grpc.Grpc;
import io.grpc.InsecureServerCredentials;
import io.grpc.Server;
import io.grpc.ServerBuilder;


import ai.onnxruntime.NodeInfo;
import ai.onnxruntime.TensorInfo;
import ai.onnxruntime.OnnxTensor;
import ai.onnxruntime.OnnxTensorLike;
import ai.onnxruntime.OrtEnvironment;
import ai.onnxruntime.OrtException;
import ai.onnxruntime.OrtSession;
import ai.onnxruntime.OrtSession.Result;
import ai.onnxruntime.OrtSession.SessionOptions;
import ai.onnxruntime.OrtSession.SessionOptions.OptLevel;
import ai.onnxruntime.OrtUtil;

import java.io.IOException;
import java.io.ByteArrayInputStream;



import com.example.GrpcTest;
import com.example.HelloServiceGrpc;

import com.example.Prediction;
import com.example.PredictionServiceGrpc;
import com.example.Prediction.ImageData;
import com.example.Prediction.CategoricalResult;

import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.Base64;
import java.util.Base64.Decoder;
import java.util.Base64.Encoder;

import javax.imageio.ImageIO;
import java.awt.image.BufferedImage;


public class App {

    public static void main(String[] args) {

        // Server server = ServerBuilder.forPort(50051) // Specify the port to listen on
        Server server = Grpc.newServerBuilderForPort(50051, InsecureServerCredentials.create())
                .addService(new HelloServiceImpl()) // Register your service implementation
                .addService(new PredictionServiceImpl())
                .build();

        try {
            // Start the gRPC server
            server.start();

            System.out.println("Server started and listening on port 50051");

            // Block until the server is shut down
            server.awaitTermination();
        } catch (Exception e) {
            e.printStackTrace();
        }

    }

    static class PredictionServiceImpl extends PredictionServiceGrpc.PredictionServiceImplBase {
        @Override
        public void imagePrediction(
            ImageData image,
            io.grpc.stub.StreamObserver<CategoricalResult> responseObserver) {

                try {
                    float[][] result = onnxRunner(image);

                    // Build and send the response
                    CategoricalResult.Builder builder = CategoricalResult.newBuilder();

                    for (float r: result[0]) {
                        builder.addResult(r);
                    } 
                    CategoricalResult response = builder.build();
                    responseObserver.onNext(response);
                    responseObserver.onCompleted();
                } catch (Exception e) {
                    e.printStackTrace();
                }
        }


        private float[][] onnxRunner(ImageData image) throws OrtException, IOException {
            OrtEnvironment env = OrtEnvironment.getEnvironment();

            OrtSession.SessionOptions opts = new SessionOptions();
            opts.setOptimizationLevel(OptLevel.BASIC_OPT);

            OrtSession pproc_sess;
            OrtSession model_sess;
            String resource_path = System.getenv("RESOURCES_PATH");

            resource_path = resource_path != null ? resource_path : "src/main/resources";

            pproc_sess = env.createSession(resource_path + "/simple_image_preprocessor.onnx", opts);
            model_sess = env.createSession(resource_path + "/mobilenetv2.onnx", opts);


            TensorInfo inputTensorInfo = (TensorInfo) model_sess.getInputInfo().get("input").getInfo();
            long[] shape = inputTensorInfo.getShape();

            String inputName = model_sess.getInputNames().iterator().next();

            // Input data
            int batch = 1;
            long channel = shape[1];
            long row = shape[2];
            long col = shape[3];
            // int pcounts = channel*row*col;

            System.out.println(channel);
            System.out.println(row);
            System.out.println(col);


            // byte[] bimg = image.toByteArray();
            // byte[] bimg = image.getData().getBytes();
            BufferedImage bimg = base64ToImage(image.getData());

            // float[] fimg = new float[pcounts];
            float[] fimg = bufferTofloatImage(bimg);

            // for (int i = 0; i < pcounts; i++) {
            //     fimg[i] = (float)(bimg[i] & 0xFF);
            //     // fimg[i] /= 255;
            // }

            // int hImg = image.getHeight();
            // int wImg = image.getWidth();
            // int cImg = image.getChannel();
            long[] orgShape = { 1, image.getChannel(), image.getHeight(), image.getWidth() };
            long[] inputShape = { 1, channel, row, col };

            OnnxTensor dataTensor = OnnxTensor.createTensor(env, fimg);
            OnnxTensor orgShapeTensor = OnnxTensor.createTensor(env, (Object)orgShape);
            OnnxTensor inputShapeTensor = OnnxTensor.createTensor(env, (Object)inputShape);

            Map<String, OnnxTensor> inputArgs = new HashMap();
            inputArgs.put("RawImg", dataTensor);
            inputArgs.put("shape", orgShapeTensor);
            inputArgs.put("sizes", inputShapeTensor);

            Result pproc_result = pproc_sess.run(inputArgs);
            float[][][][] pproc_img = (float[][][][])pproc_result.get(0).getValue();


            // long[] tshape = { 1, channel, row, col };
            // Object inputImg = OrtUtil.reshape(fimg, tshape);

            // OnnxTensor inputTensor = OnnxTensor.createTensor(env, inputImg);
            OnnxTensor inputTensor = OnnxTensor.createTensor(env, pproc_img);

            Result output = model_sess.run(Collections.singletonMap(inputName, inputTensor));
            return (float[][])output.get(0).getValue();

        }

        private float[] bufferTofloatImage(BufferedImage decodedImage) throws IOException {
            int width = decodedImage.getWidth();
            int height = decodedImage.getHeight();

            float[] fimg = new float[width * height * 3];
            for (int i = 0; i < fimg.length; i++) {
                fimg[i] = -1;
            }

            for (int y = 0; y < height; y++) {
                for (int x = 0; x < width; x++) {
                    int rgb = decodedImage.getRGB(x, y);
                    int r = (rgb >> 16) & 0xFF;
                    int g = (rgb >> 8) & 0xFF;
                    int b = rgb & 0xFF;
                    fimg[y * width + x] = (float) r;
                    fimg[width * height + y * width + x] = (float) g;
                    fimg[2 * width * height + y * width + x] = (float) b;
                }
            }

            return fimg;
        }

        private BufferedImage base64ToImage(String base64) throws IOException {
            Decoder decoder = Base64.getDecoder();
            byte[] decodedBytes = decoder.decode(base64);
            ByteArrayInputStream decodedByteImage = new ByteArrayInputStream(decodedBytes);
            return ImageIO.read(decodedByteImage);
        }
    }


    static class HelloServiceImpl extends HelloServiceGrpc.HelloServiceImplBase {
        @Override
        public void sayHello(
            GrpcTest.HelloRequest request,
            io.grpc.stub.StreamObserver<GrpcTest.HelloResponse> responseObserver) {
            
            // Implement your server-side logic here
            String message = "Hello, " + request.getName();
            System.out.println(message);

            // Build and send the response
            GrpcTest.HelloResponse response = GrpcTest.HelloResponse
                .newBuilder()
                .setGreeting(message)
                .build();

            responseObserver.onNext(response);
            responseObserver.onCompleted();
        }
    }

}
